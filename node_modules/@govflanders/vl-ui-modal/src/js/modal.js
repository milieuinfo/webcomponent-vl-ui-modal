import dialogPolyfill from 'dialog-polyfill';

const mAttr = `data-${vl.ns}modal`,
  mDressedAtt = `${mAttr}-dressed`,
  mClosable = `${mAttr}-closable`,
  mOpen = `${mAttr}-open`,
  mClose = `${mAttr}-close`,
  mFallbackBackdropClass = '.backdrop',
  noOverflowClass = `${vl.ns}u-no-overflow`;

class Modal {
  constructor() {
    this.lastClickedToggle = null;
  }

  toggle(element, forceClose = false) {
    const visible = element.hasAttribute('open');

    if (visible || forceClose) {
      if (visible) {
        element.close();
      }

      this.lastClickedToggle.focus();
      vl.util.removeClass(document.body, noOverflowClass);
    } else {
      element.showModal();
      vl.util.addClass(document.body, noOverflowClass);
    }

    element.setAttribute('aria-hidden', !visible);
  }

  dress(element) {
    let linkedOpenTrigger,
      linkedClosedTrigger,
      closable = false,
      self = this;

    // Register polyfill
    dialogPolyfill.registerDialog(element);

    // Add bound attribute
    element.setAttribute(mDressedAtt, true);

    // Handle open/close
    linkedOpenTrigger = document.querySelectorAll(`[${mOpen}="${element.id}"]`);
    linkedClosedTrigger = document.querySelectorAll(`[${mClose}]`);

    // See if closable (by esc or backdrop)
    closable = element.hasAttribute(mClosable);

    vl.util.each(linkedOpenTrigger, openTrigger => {
      openTrigger.addEventListener('click', function(event) {
        self.lastClickedToggle = this;

        if (!element.hasAttribute('open')) {
          self.toggle(element);
        }

        event.preventDefault();
      });
    });

    vl.util.each(linkedClosedTrigger, closeTrigger => {
      closeTrigger.addEventListener('click', function() {
        if (element.hasAttribute('open')) {
          self.toggle(element);
        }
      });
    });

    // If attribute closable is available
    if (closable) {
      // Make sure click outside of element closes modal
      document.addEventListener('click', (event) => {
        if (element.hasAttribute('open')) {
          let dialogBounds = element.getBoundingClientRect(),
            isInDialog = event.clientY > dialogBounds.top
              && event.clientY < dialogBounds.top + dialogBounds.height
              && event.clientX > dialogBounds.left
              && event.clientX < dialogBounds.left + dialogBounds.width;

          if (!isInDialog && (event.target.tagName === 'DIALOG' || vl.util.hasClass(event.target, mFallbackBackdropClass))) {
            self.toggle(element);
          }
        }
      });

      element.addEventListener('close', () => {
        self.toggle(element, true);
      });
    } else {
      element.addEventListener('keydown', event => {
        if (event.keyCode === 27) {
          event.preventDefault();
        }
      });
    }
  }

  dressAll() {
    const elements = document.querySelectorAll(
      `[${mAttr}]:not([${mDressedAtt}]):not([data-${vl.ns}js-dress="false"])`
    );

    vl.util.each(elements, element => {
      this.dress(element);
    });
  }
}

if(!('modal' in vl)) {
  vl.modal = new Modal();
  vl.modal.dressAll();
}

export default Modal;
